import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';
import { setAlert } from './alertSlice';

// Get all vulnerabilities
export const getAllVulnerabilities = createAsyncThunk(
  'vulnerabilities/getAllVulnerabilities',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get('/api/vulnerabilities');
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch vulnerabilities';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get vulnerability by ID
export const getVulnerabilityById = createAsyncThunk(
  'vulnerabilities/getVulnerabilityById',
  async (id, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get(`/api/vulnerabilities/${id}`);
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch vulnerability';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Update vulnerability status
export const updateVulnerabilityStatus = createAsyncThunk(
  'vulnerabilities/updateVulnerabilityStatus',
  async ({ id, status, assignedTo }, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.put(`/api/vulnerabilities/${id}`, { status, assignedTo });
      dispatch(setAlert({ message: 'Vulnerability status updated successfully', type: 'success' }));
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to update vulnerability status';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get project vulnerabilities
export const getProjectVulnerabilities = createAsyncThunk(
  'vulnerabilities/getProjectVulnerabilities',
  async (projectId, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get(`/api/projects/${projectId}/vulnerabilities`);
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch project vulnerabilities';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get vulnerability statistics by category
export const getVulnerabilityStatsByCategory = createAsyncThunk(
  'vulnerabilities/getVulnerabilityStatsByCategory',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get('/api/vulnerabilities/stats/by-category');
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch vulnerability statistics';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get project vulnerability statistics by category
export const getProjectVulnerabilityStatsByCategory = createAsyncThunk(
  'vulnerabilities/getProjectVulnerabilityStatsByCategory',
  async (projectId, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get(`/api/projects/${projectId}/vulnerabilities/stats/by-category`);
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch project vulnerability statistics';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get vulnerability statistics by severity
export const getVulnerabilityStatsBySeverity = createAsyncThunk(
  'vulnerabilities/getVulnerabilityStatsBySeverity',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get('/api/vulnerabilities/stats/by-severity');
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch vulnerability statistics';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get project vulnerability statistics by severity
export const getProjectVulnerabilityStatsBySeverity = createAsyncThunk(
  'vulnerabilities/getProjectVulnerabilityStatsBySeverity',
  async (projectId, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get(`/api/projects/${projectId}/vulnerabilities/stats/by-severity`);
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch project vulnerability statistics';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Get vulnerability trend
export const getVulnerabilityTrend = createAsyncThunk(
  'vulnerabilities/getVulnerabilityTrend',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const res = await axios.get('/api/vulnerabilities/stats/trend');
      return res.data;
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to fetch vulnerability trend';
      dispatch(setAlert({ message: errorMessage, type: 'error' }));
      return rejectWithValue(errorMessage);
    }
  }
);

// Initial state
const initialState = {
  vulnerabilities: [],
  vulnerability: null,
  categoryStats: [],
  severityStats: [],
  trendData: [],
  loading: false,
  error: null
};

// Vulnerability slice
const vulnerabilitySlice = createSlice({
  name: 'vulnerabilities',
  initialState,
  reducers: {
    clearVulnerability: (state) => {
      state.vulnerability = null;
    },
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Get all vulnerabilities
      .addCase(getAllVulnerabilities.pending, (state) => {
        state.loading = true;
      })
      .addCase(getAllVulnerabilities.fulfilled, (state, action) => {
        state.loading = false;
        state.vulnerabilities = action.payload;
      })
      .addCase(getAllVulnerabilities.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get vulnerability by ID
      .addCase(getVulnerabilityById.pending, (state) => {
        state.loading = true;
      })
      .addCase(getVulnerabilityById.fulfilled, (state, action) => {
        state.loading = false;
        state.vulnerability = action.payload;
      })
      .addCase(getVulnerabilityById.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Update vulnerability status
      .addCase(updateVulnerabilityStatus.pending, (state) => {
        state.loading = true;
      })
      .addCase(updateVulnerabilityStatus.fulfilled, (state, action) => {
        state.loading = false;
        state.vulnerability = action.payload;
        
        // Update in the list if it exists
        const index = state.vulnerabilities.findIndex(v => v._id === action.payload._id);
        if (index !== -1) {
          state.vulnerabilities[index] = action.payload;
        }
      })
      .addCase(updateVulnerabilityStatus.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get project vulnerabilities
      .addCase(getProjectVulnerabilities.pending, (state) => {
        state.loading = true;
      })
      .addCase(getProjectVulnerabilities.fulfilled, (state, action) => {
        state.loading = false;
        state.vulnerabilities = action.payload;
      })
      .addCase(getProjectVulnerabilities.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get vulnerability statistics by category
      .addCase(getVulnerabilityStatsByCategory.pending, (state) => {
        state.loading = true;
      })
      .addCase(getVulnerabilityStatsByCategory.fulfilled, (state, action) => {
        state.loading = false;
        state.categoryStats = action.payload;
      })
      .addCase(getVulnerabilityStatsByCategory.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get project vulnerability statistics by category
      .addCase(getProjectVulnerabilityStatsByCategory.pending, (state) => {
        state.loading = true;
      })
      .addCase(getProjectVulnerabilityStatsByCategory.fulfilled, (state, action) => {
        state.loading = false;
        state.categoryStats = action.payload;
      })
      .addCase(getProjectVulnerabilityStatsByCategory.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get vulnerability statistics by severity
      .addCase(getVulnerabilityStatsBySeverity.pending, (state) => {
        state.loading = true;
      })
      .addCase(getVulnerabilityStatsBySeverity.fulfilled, (state, action) => {
        state.loading = false;
        state.severityStats = action.payload;
      })
      .addCase(getVulnerabilityStatsBySeverity.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get project vulnerability statistics by severity
      .addCase(getProjectVulnerabilityStatsBySeverity.pending, (state) => {
        state.loading = true;
      })
      .addCase(getProjectVulnerabilityStatsBySeverity.fulfilled, (state, action) => {
        state.loading = false;
        state.severityStats = action.payload;
      })
      .addCase(getProjectVulnerabilityStatsBySeverity.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // Get vulnerability trend
      .addCase(getVulnerabilityTrend.pending, (state) => {
        state.loading = true;
      })
      .addCase(getVulnerabilityTrend.fulfilled, (state, action) => {
        state.loading = false;
        state.trendData = action.payload;
      })
      .addCase(getVulnerabilityTrend.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  }
});

export const { clearVulnerability, clearError } = vulnerabilitySlice.actions;

export default vulnerabilitySlice.reducer;